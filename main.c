//Девятков Т.И Б20-В02
//
//Вариант 5 
//Написать программу для работы с перемешанной таблицей, использующей перемешивание сложением, по запросам оператора.
//Перемешанная таблица организована вектором; каждый элемент таблицы имеет следующую структуру :
//struct Item {
//	int busy;		/* признак занятости элемента*/
//	int key;		/* ключ элемента				*/
//	char* info;	/* указатель на информацию	
//};
//
//Максимальный размер таблицы ограничен(для задания максимального размера таблицы использовать константу – например, const int SIZE = ...;).
//Для доступа к элементам таблицы использовать двойное хеширование.
//Предусмотреть следующие операции :
//-	включение нового элемента в таблицу при условии, что в таблице не может быть двух элементов с одинаковыми ключами; если при включении нового
//элемента возникает такая ситуация, на экран должно быть выведено сообщение об ошибке;
//-	удаление из таблицы элемента, заданного своим ключом;
//-	поиск элемента по заданному ключу.Результатом поиска должен быть новый элемент таблицы, содержащий найденный элемент.Если заданный элемент в
//таблице отсутствует, вывести на экран сообщение об ошибке;
//-	вывод содержимого таблицы на экран.
//Разработать два варианта программы :
//a)	и сама таблица, и информация, относящаяся к элементу таблицы, хранятся в основной памяти;
//b)	и сама таблица, и информация, относящаяся к элементу таблицы, хранятся во внешней памяти(используется двоичный файл произвольного доступа).
//Все операции выполняются с таблицей, размещенной в основной памяти.Таблица считывается из файла(или создается в первый раз) в начале сеанса работы 
//и записывается в файл в конце сеанса работы.Информация, относящаяся к элементу таблицы, записывается в файл сразу же при выполнении операции включения
//в таблицу.Имя файла вводится по запросу из программы.

#include <stdio.h>
#include <malloc.h>
#include <string.h>
#include "hash_table.h"
#include "utilits.h"

int main()
{	
	int capacity = 5, choice = 0, availability = 0;
	key_t key = 0;
	capacity = get_size(capacity);
	init_table(capacity);

	do {
		print_menu();
		choice = select_action(choice);
		//system("pause");
		if (choice == EXIT)
			break;
		if (choice == ADD_ELEMENT)
		{
			key = get_key(key);

			availability = insert(key, capacity);
				if (availability == -1)
					duplicated_key();
				if (availability == -2)
					full_table();
		}
		if (choice == DELETE_ELEMENT)
		{
			key = get_key(key);

			availability =  delete_element(key, capacity);
			if (availability == -1) {
				not_found();
			}
			else
				printf("deleted");
		}
		if (choice == FIND_ELEMENT)
		{
			key = get_key(key);
			availability = search(key, capacity);
			if (availability == -1) {
				not_found();
			}
			else
				show_element(availability);
		}
		if (choice == SHOW_TABLE)
		{
			print_table(capacity);
		}
	} while (choice != 0);
	
	free(vector->info);
	free(vector);

	system("pause");
	return 0;
}